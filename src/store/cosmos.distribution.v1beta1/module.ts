// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import {
  EncodeObject,
  GeneratedType,
  OfflineSigner,
  Registry,
} from "@cosmjs/proto-signing";
import { msgTypes } from "./registry";
import { IgniteClient } from "../client";
import { MissingWalletError } from "../helpers";
import { Api } from "./rest";
import { MsgSetWithdrawAddress } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgWithdrawValidatorCommission } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgWithdrawDelegatorReward } from "./types/cosmos/distribution/v1beta1/tx";
import { MsgFundCommunityPool } from "./types/cosmos/distribution/v1beta1/tx";

import { Params as typeParams } from "./types";
import { ValidatorHistoricalRewards as typeValidatorHistoricalRewards } from "./types";
import { ValidatorCurrentRewards as typeValidatorCurrentRewards } from "./types";
import { ValidatorAccumulatedCommission as typeValidatorAccumulatedCommission } from "./types";
import { ValidatorOutstandingRewards as typeValidatorOutstandingRewards } from "./types";
import { ValidatorSlashEvent as typeValidatorSlashEvent } from "./types";
import { ValidatorSlashEvents as typeValidatorSlashEvents } from "./types";
import { FeePool as typeFeePool } from "./types";
import { CommunityPoolSpendProposal as typeCommunityPoolSpendProposal } from "./types";
import { DelegatorStartingInfo as typeDelegatorStartingInfo } from "./types";
import { DelegationDelegatorReward as typeDelegationDelegatorReward } from "./types";
import { CommunityPoolSpendProposalWithDeposit as typeCommunityPoolSpendProposalWithDeposit } from "./types";
import { DelegatorWithdrawInfo as typeDelegatorWithdrawInfo } from "./types";
import { ValidatorOutstandingRewardsRecord as typeValidatorOutstandingRewardsRecord } from "./types";
import { ValidatorAccumulatedCommissionRecord as typeValidatorAccumulatedCommissionRecord } from "./types";
import { ValidatorHistoricalRewardsRecord as typeValidatorHistoricalRewardsRecord } from "./types";
import { ValidatorCurrentRewardsRecord as typeValidatorCurrentRewardsRecord } from "./types";
import { DelegatorStartingInfoRecord as typeDelegatorStartingInfoRecord } from "./types";
import { ValidatorSlashEventRecord as typeValidatorSlashEventRecord } from "./types";
import { QueryValidatorOutstandingRewardsRequest as typeQueryValidatorOutstandingRewardsRequest } from "./types";
import { QueryValidatorOutstandingRewardsResponse as typeQueryValidatorOutstandingRewardsResponse } from "./types";
import { QueryValidatorCommissionRequest as typeQueryValidatorCommissionRequest } from "./types";
import { QueryValidatorCommissionResponse as typeQueryValidatorCommissionResponse } from "./types";
import { QueryValidatorSlashesRequest as typeQueryValidatorSlashesRequest } from "./types";
import { QueryValidatorSlashesResponse as typeQueryValidatorSlashesResponse } from "./types";
import { QueryDelegationTotalRewardsRequest as typeQueryDelegationTotalRewardsRequest } from "./types";
import { QueryDelegationTotalRewardsResponse as typeQueryDelegationTotalRewardsResponse } from "./types";
import { QueryDelegatorValidatorsRequest as typeQueryDelegatorValidatorsRequest } from "./types";
import { QueryDelegatorValidatorsResponse as typeQueryDelegatorValidatorsResponse } from "./types";
import { QueryDelegatorWithdrawAddressRequest as typeQueryDelegatorWithdrawAddressRequest } from "./types";
import { QueryDelegatorWithdrawAddressResponse as typeQueryDelegatorWithdrawAddressResponse } from "./types";
import { QueryCommunityPoolRequest as typeQueryCommunityPoolRequest } from "./types";
import { QueryCommunityPoolResponse as typeQueryCommunityPoolResponse } from "./types";
import { MsgSetWithdrawAddressResponse as typeMsgSetWithdrawAddressResponse } from "./types";
import { MsgWithdrawValidatorCommissionResponse as typeMsgWithdrawValidatorCommissionResponse } from "./types";
import { MsgFundCommunityPoolResponse as typeMsgFundCommunityPoolResponse } from "./types";

export {
  MsgSetWithdrawAddress,
  MsgWithdrawValidatorCommission,
  MsgWithdrawDelegatorReward,
  MsgFundCommunityPool,
};

type sendMsgSetWithdrawAddressParams = {
  value: MsgSetWithdrawAddress;
  fee?: StdFee;
  memo?: string;
};

type sendMsgWithdrawValidatorCommissionParams = {
  value: MsgWithdrawValidatorCommission;
  fee?: StdFee;
  memo?: string;
};

type sendMsgWithdrawDelegatorRewardParams = {
  value: MsgWithdrawDelegatorReward;
  fee?: StdFee;
  memo?: string;
};

type sendMsgFundCommunityPoolParams = {
  value: MsgFundCommunityPool;
  fee?: StdFee;
  memo?: string;
};

type msgSetWithdrawAddressParams = {
  value: MsgSetWithdrawAddress;
};

type msgWithdrawValidatorCommissionParams = {
  value: MsgWithdrawValidatorCommission;
};

type msgWithdrawDelegatorRewardParams = {
  value: MsgWithdrawDelegatorReward;
};

type msgFundCommunityPoolParams = {
  value: MsgFundCommunityPool;
};

export const registry = new Registry(msgTypes);

type Field = {
  name: string;
  type: unknown;
};
function getStructure(template) {
  const structure: { fields: Field[] } = { fields: [] };
  for (let [key, value] of Object.entries(template)) {
    let field = { name: key, type: typeof value };
    structure.fields.push(field);
  }
  return structure;
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string;
  prefix: string;
  signer?: OfflineSigner;
}

export const txClient = (
  { signer, prefix, addr }: TxClientOptions = {
    addr: "http://localhost:26657",
    prefix: "cosmos",
  }
) => {
  return {
    async sendMsgSetWithdrawAddress({
      value,
      fee,
      memo,
    }: sendMsgSetWithdrawAddressParams): Promise<DeliverTxResponse> {
      if (!signer) {
        throw new Error(
          "TxClient:sendMsgSetWithdrawAddress: Unable to sign Tx. Signer is not present."
        );
      }
      try {
        const { address } = (await signer.getAccounts())[0];
        const signingClient = await SigningStargateClient.connectWithSigner(
          addr,
          signer,
          { registry }
        );
        let msg = this.msgSetWithdrawAddress({
          value: MsgSetWithdrawAddress.fromPartial(value),
        });
        return await signingClient.signAndBroadcast(
          address,
          [msg],
          fee ? fee : defaultFee,
          memo
        );
      } catch (e: any) {
        throw new Error(
          "TxClient:sendMsgSetWithdrawAddress: Could not broadcast Tx: " +
            e.message
        );
      }
    },

    async sendMsgWithdrawValidatorCommission({
      value,
      fee,
      memo,
    }: sendMsgWithdrawValidatorCommissionParams): Promise<DeliverTxResponse> {
      if (!signer) {
        throw new Error(
          "TxClient:sendMsgWithdrawValidatorCommission: Unable to sign Tx. Signer is not present."
        );
      }
      try {
        const { address } = (await signer.getAccounts())[0];
        const signingClient = await SigningStargateClient.connectWithSigner(
          addr,
          signer,
          { registry }
        );
        let msg = this.msgWithdrawValidatorCommission({
          value: MsgWithdrawValidatorCommission.fromPartial(value),
        });
        return await signingClient.signAndBroadcast(
          address,
          [msg],
          fee ? fee : defaultFee,
          memo
        );
      } catch (e: any) {
        throw new Error(
          "TxClient:sendMsgWithdrawValidatorCommission: Could not broadcast Tx: " +
            e.message
        );
      }
    },

    async sendMsgWithdrawDelegatorReward({
      value,
      memo,
    }: sendMsgWithdrawDelegatorRewardParams): Promise<DeliverTxResponse> {
      if (!signer) {
        throw new Error(
          "TxClient:sendMsgWithdrawDelegatorReward: Unable to sign Tx. Signer is not present."
        );
      }
      try {
        const { address } = (await signer.getAccounts())[0];
        const signingClient = await SigningStargateClient.connectWithSigner(
          addr,
          signer,
          { registry }
        );
        let msg = this.msgWithdrawDelegatorReward({
          value: MsgWithdrawDelegatorReward.fromPartial(value),
        });

        const gas_used = await signingClient.simulate(address, [msg], memo);
        const gas_adj = 2;
        const gas = parseInt(`${gas_used * gas_adj}`);
        const gas_fee = parseInt(`${gas * 0.0005}`) + 1;

        const fee = {
          amount: [{ denom: "umec", amount: `${gas_fee}` }],
          gas: String(gas),
        };

        return await signingClient.signAndBroadcast(
          address,
          [msg],
          fee ? fee : defaultFee,
          memo
        );
      } catch (e: any) {
        throw new Error(
          "TxClient:sendMsgWithdrawDelegatorReward: Could not broadcast Tx: " +
            e.message
        );
      }
    },

    async sendMsgFundCommunityPool({
      value,
      fee,
      memo,
    }: sendMsgFundCommunityPoolParams): Promise<DeliverTxResponse> {
      if (!signer) {
        throw new Error(
          "TxClient:sendMsgFundCommunityPool: Unable to sign Tx. Signer is not present."
        );
      }
      try {
        const { address } = (await signer.getAccounts())[0];
        const signingClient = await SigningStargateClient.connectWithSigner(
          addr,
          signer,
          { registry }
        );
        let msg = this.msgFundCommunityPool({
          value: MsgFundCommunityPool.fromPartial(value),
        });
        return await signingClient.signAndBroadcast(
          address,
          [msg],
          fee ? fee : defaultFee,
          memo
        );
      } catch (e: any) {
        throw new Error(
          "TxClient:sendMsgFundCommunityPool: Could not broadcast Tx: " +
            e.message
        );
      }
    },

    msgSetWithdrawAddress({
      value,
    }: msgSetWithdrawAddressParams): EncodeObject {
      try {
        return {
          typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
          value: MsgSetWithdrawAddress.fromPartial(value),
        };
      } catch (e: any) {
        throw new Error(
          "TxClient:MsgSetWithdrawAddress: Could not create message: " +
            e.message
        );
      }
    },

    msgWithdrawValidatorCommission({
      value,
    }: msgWithdrawValidatorCommissionParams): EncodeObject {
      try {
        return {
          typeUrl:
            "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
          value: MsgWithdrawValidatorCommission.fromPartial(value),
        };
      } catch (e: any) {
        throw new Error(
          "TxClient:MsgWithdrawValidatorCommission: Could not create message: " +
            e.message
        );
      }
    },

    msgWithdrawDelegatorReward({
      value,
    }: msgWithdrawDelegatorRewardParams): EncodeObject {
      try {
        return {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: MsgWithdrawDelegatorReward.fromPartial(value),
        };
      } catch (e: any) {
        throw new Error(
          "TxClient:MsgWithdrawDelegatorReward: Could not create message: " +
            e.message
        );
      }
    },

    msgFundCommunityPool({ value }: msgFundCommunityPoolParams): EncodeObject {
      try {
        return {
          typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
          value: MsgFundCommunityPool.fromPartial(value),
        };
      } catch (e: any) {
        throw new Error(
          "TxClient:MsgFundCommunityPool: Could not create message: " +
            e.message
        );
      }
    },
  };
};

interface QueryClientOptions {
  addr: string;
}

export const queryClient = (
  { addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }
) => {
  return new Api({ baseURL: addr });
};
export default { txClient, queryClient };
